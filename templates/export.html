<link rel="stylesheet" href="./css/export.css" />
<main>
  <div class="status">
    <p>Sync data with other device.</p>
    <p id="status-message">Enter code and toggle the switch to connect.</p>
  </div>
  <div class="code-container">
    <input
      aria-label="connection code"
      type="tel"
      maxlength="7"
      id="code-input"
      pattern="[0-9]{3}-[0-9]{3}"
      placeholder="123-456"
    />
    <button id="generateButton"></button>
    <button title="connect devices" id="connectButton"></button>
  </div>
  <div class="controls">
    <button title="sync data" id="syncButton" disabled style="display: none">
      Sync
    </button>
  </div>
  <div id="userCount"></div>
  <textarea id="msgs"></textarea>
  <div class="data">
    <h2 id="showData">Show Data</h2>
    <div class="data-container">
      <textarea id="json"></textarea>
      <button title="save date" id="saveData" disabled>Save Data</button>
    </div>
  </div>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="./js/export.js"></script>
<script>
  (function () {
    const container = document.querySelector(".code-container");
    const codeInput = document.getElementById("code-input");
    const generateButton = document.getElementById("generateButton");
    const syncButton = document.getElementById("syncButton");
    const connectButton = document.getElementById("connectButton");
    const statusMessage = document.getElementById("status-message");
    //connectButton.style.visibility = 'hidden';
    let socket = null;
    let peerConnection = null;
    let dataChannel = null;
    let isInitiator = false;
    let webrtcConnected = false;
    let offerCreationTimeout = null;
    let connectedDevices = {}; // Store connected devices: { socketId: { deviceType, socketId } }
    let myDeviceType = null; // Store this device's type
    generateButton.addEventListener("click", () => {
      const randomCode = `${Math.floor(100 + Math.random() * 900)}-${Math.floor(
        100 + Math.random() * 900
      )}`;
      codeInput.value = randomCode;
      container.classList.add("validCode");
      //connectButton.style.visibility = 'visible';
    });
    codeInput.addEventListener("input", function (event) {
      let input = event.target;
      let value = input.value.replace(/\D/g, ""); // Remove any non-digit characters
      // Format as XXX-XXX
      if (value.length > 3) {
        value = value.slice(0, 3) + "-" + value.slice(3, 6);
      }
      input.value = value;
      const isValidCode = /^\d{3}-\d{3}$/.test(input.value);
      container.classList.toggle("validCode", isValidCode);
      //connectButton.style.visibility = isValidCode ? 'visible' : 'hidden';
    });
    connectButton.addEventListener("click", () => {
      const code = codeInput.value;
      syncButton.disabled = true;
      // Validate code format
      if (/^\d{3}-\d{3}$/.test(code)) {
        codeInput.style.display = "hidden";
        if (socket && socket.connected) {
          console.log("Disconnecting existing socket connection...");
          socket.disconnect(); // Disconnect the existing socket connection
          generateButton.style.display = "block";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          syncButton.disabled = true;
          return;
        }
        socket = io(`https://bw-socket-test.herokuapp.com/${code}`, {
          transports: ["websocket", "polling"],
          timeout: 10000,
          reconnection: false,
        });

        socket.on("connect", () => {
          console.log(`Connected with namespace: /${code}`);
          generateButton.style.display = "none";
          container.classList.add("connected");
          codeInput.readOnly = true;
          console.log("set connection id");
          setAppSetting("connect_id", code);

          // Detect and store this device's type
          myDeviceType = detectDeviceType();
          console.log("Device type detected:", myDeviceType);

          // Emit device info to other devices
          socket.emit("deviceInfo", {
            deviceType: myDeviceType,
            socketId: socket.id,
          });

          // Store this device in connectedDevices
          connectedDevices[socket.id] = {
            deviceType: myDeviceType,
            socketId: socket.id,
          };
          updateDeviceListDisplay();

          // Determine if this device is the initiator (first to connect)
          // We'll use a simple approach: first device to connect becomes initiator
          socket.emit("checkInitiator");
        });

        socket.on("connect_error", (error) => {
          console.error("Socket.io connection error:", error);
          statusMessage.innerHTML =
            "Connection failed. This may be due to CORS restrictions when running locally.<br>Try using the hosted version or configure the server to allow localhost.";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          generateButton.style.display = "block";
          if (socket) {
            socket.disconnect();
            socket = null;
          }
        });
        socket.on("deviceInfo", (deviceInfo) => {
          console.log("Received device info:", deviceInfo);
          if (deviceInfo && deviceInfo.socketId && deviceInfo.deviceType) {
            // Store device info
            connectedDevices[deviceInfo.socketId] = {
              deviceType: deviceInfo.deviceType,
              socketId: deviceInfo.socketId,
            };
            updateDeviceListDisplay();
          }
        });

        socket.on("userCount", (count) => {
          if (count > 1) {
            const otherDevices = Object.values(connectedDevices).filter(
              (device) => device.socketId !== socket?.id
            );
            const deviceTypes = otherDevices.map((device) => device.deviceType);
            const uniqueTypes = [...new Set(deviceTypes)];

            if (uniqueTypes.length > 0) {
              statusMessage.innerHTML = `Connected with ${uniqueTypes.join(
                ", "
              )}.<br>Connecting...`;
            } else {
              statusMessage.innerHTML = `Connected with ${
                count - 1
              } other device${count - 1 === 1 ? "" : "s"}.<br>Connecting...`;
            }

            // Start WebRTC connection process when both devices are connected
            if (
              count === 2 &&
              !webrtcConnected &&
              !peerConnection &&
              !offerCreationTimeout
            ) {
              // Use socket ID as tiebreaker for deterministic initiator selection
              // Device with "smaller" socket ID becomes initiator
              const socketId = socket.id;
              const delay = Math.random() * 800 + 200; // 200-1000ms random delay

              // Add a small deterministic component based on socket ID
              const idHash = socketId
                .split("")
                .reduce((acc, char) => acc + char.charCodeAt(0), 0);
              const deterministicDelay = idHash % 500; // 0-500ms based on socket ID
              const totalDelay = delay + deterministicDelay;

              console.log(
                `Scheduling offer creation in ${totalDelay.toFixed(
                  0
                )}ms (socket ID: ${socketId.substring(0, 8)}...)`
              );
              offerCreationTimeout = setTimeout(() => {
                // Only create offer if we still haven't received one
                if (!peerConnection && !webrtcConnected && !isInitiator) {
                  isInitiator = true;
                  console.log("This device is the initiator (creating offer)");
                  createWebRTCOffer();
                } else {
                  console.log(
                    "Skipping offer creation - already have connection or received offer"
                  );
                }
                offerCreationTimeout = null;
              }, totalDelay);
            }
          } else {
            statusMessage.innerHTML = "Waiting for another device to connectâ€¦";
            // Clean up disconnected devices when count decreases
            Object.keys(connectedDevices).forEach((socketId) => {
              if (socketId !== socket?.id) {
                delete connectedDevices[socketId];
              }
            });
            updateDeviceListDisplay();
          }
        });

        // Handle both WebRTC signaling and regular sync via the existing 'sync' event
        // WebRTC signals are wrapped in { _webrtcSignal: {...} } format
        // Regular sync data is compressed/encoded as before
        // The server already broadcasts 'sync' events, so this works without server changes
        socket.on("sync", async (data) => {
          if (webrtcConnected) {
            // If already connected via WebRTC, ignore sync events (they're for fallback)
            return;
          }

          try {
            // Check if this is a WebRTC signal (wrapped in special format) or regular sync data
            let signalData = null;
            try {
              // Try to parse as WebRTC signal wrapper
              const parsed = typeof data === "string" ? JSON.parse(data) : data;
              if (parsed && parsed._webrtcSignal) {
                signalData = parsed._webrtcSignal;
                console.log(
                  "Received WebRTC signal via sync:",
                  signalData?.type,
                  "from:",
                  signalData?.fromSocketId || "unknown"
                );
              }
            } catch (e) {
              // Not a WebRTC signal, treat as regular sync data (fallback)
              console.log("sync request (fallback)");
              const jsonData = decompressData(decodeURIComponent(data));
              console.log("Decompressed JSON Data:", jsonData);
              statusMessage.innerHTML = "Syncing data...";
              importData(jsonData).then(() => {
                statusMessage.innerHTML = "Sync completed!";
              });
              return;
            }

            // Handle WebRTC signal
            if (!signalData) return;

            if (signalData.type === "offer") {
              // If we receive an offer, we're definitely the responder (regardless of current state)
              // Don't show technical message - statusMessage already shows "Establishing peer connection..."
              console.log("Received WebRTC offer");

              // Store device info from WebRTC signal
              if (signalData.deviceType && signalData.fromSocketId) {
                connectedDevices[signalData.fromSocketId] = {
                  deviceType: signalData.deviceType,
                  socketId: signalData.fromSocketId,
                };
                updateDeviceListDisplay();
              }

              // Cancel any pending offer creation
              if (offerCreationTimeout) {
                console.log(
                  "Cancelling pending offer creation - received offer from other device"
                );
                clearTimeout(offerCreationTimeout);
                offerCreationTimeout = null;
              }
              if (peerConnection) {
                console.log(
                  "Already have peer connection, closing it to accept new offer"
                );
                peerConnection.close();
                peerConnection = null;
              }
              // Mark as responder
              isInitiator = false;
              await handleWebRTCOffer(signalData.offer);
            } else if (signalData.type === "answer") {
              // Only handle answer if we're the initiator (we sent an offer)
              // If we received an offer first, we're the responder and should ignore answers
              if (
                isInitiator &&
                peerConnection &&
                peerConnection.localDescription &&
                peerConnection.localDescription.type === "offer"
              ) {
                // Don't show technical message - statusMessage already shows connection status
                console.log("Received WebRTC answer");

                // Store device info from WebRTC signal
                if (signalData.deviceType && signalData.fromSocketId) {
                  connectedDevices[signalData.fromSocketId] = {
                    deviceType: signalData.deviceType,
                    socketId: signalData.fromSocketId,
                  };
                  updateDeviceListDisplay();
                }

                await handleWebRTCAnswer(signalData.answer);
              } else {
                console.log(
                  "Ignoring answer - we're the responder, not the initiator"
                );
              }
            } else if (signalData.type === "ice-candidate") {
              iceCandidatesReceived++;
              // Don't show technical message to users - just log for debugging
              console.log(
                `Received ICE candidate ${iceCandidatesReceived}:`,
                signalData.candidate
              );

              // Store device info from WebRTC signal (if not already stored)
              if (
                signalData.deviceType &&
                signalData.fromSocketId &&
                !connectedDevices[signalData.fromSocketId]
              ) {
                connectedDevices[signalData.fromSocketId] = {
                  deviceType: signalData.deviceType,
                  socketId: signalData.fromSocketId,
                };
                updateDeviceListDisplay();
              }

              if (peerConnection) {
                try {
                  if (peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(
                      new RTCIceCandidate(signalData.candidate)
                    );
                  } else {
                    // Store candidate for later if remote description isn't set yet
                    console.log(
                      "Storing ICE candidate until remote description is set"
                    );
                    // The candidate will be added when remote description is set
                  }
                } catch (error) {
                  console.error("Error adding ICE candidate:", error);
                  window.error("Error adding ICE candidate:", error);
                }
              } else {
                console.log("Peer connection not created yet");
              }
            } else {
              console.log(
                "Ignored signal:",
                signalData?.type,
                "isInitiator:",
                isInitiator
              );
            }
          } catch (error) {
            console.error("Error handling sync/signal:", error);
            window.error("Error handling sync/signal:", error);
          }
        });
      }
    });
    // WebRTC functions
    let webrtcTimeout = null;
    let iceCandidatesReceived = 0;
    let iceCandidatesSent = 0;

    // Device type detection
    function detectDeviceType() {
      const ua = navigator.userAgent.toLowerCase();
      if (/tablet|ipad|playbook|silk/i.test(ua)) return "Tablet";
      if (
        /mobile|iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(
          ua
        )
      )
        return "Mobile";
      return "Desktop";
    }

    // Update device list display
    function updateDeviceListDisplay() {
      const userCountEl = document.getElementById("userCount");
      if (!userCountEl) return;

      const otherDevices = Object.values(connectedDevices).filter(
        (device) => device.socketId !== socket?.id
      );

      if (otherDevices.length === 0) {
        userCountEl.textContent = "";
        return;
      }

      const deviceTypes = otherDevices.map((device) => device.deviceType);
      const uniqueTypes = [...new Set(deviceTypes)];
      userCountEl.textContent = `Connected with: ${uniqueTypes.join(", ")}`;
    }

    function createWebRTCOffer() {
      console.log("Creating WebRTC offer...");
      statusMessage.innerHTML = "Connecting...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      // Create data channel
      dataChannel = peerConnection.createDataChannel("sync", { ordered: true });
      setupDataChannel(dataChannel);

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          iceCandidatesSent++;
          console.log(
            `Sending ICE candidate ${iceCandidatesSent}:`,
            event.candidate
          );
          // Send WebRTC signal via sync event (wrapped in special format)
          socket.emit(
            "sync",
            JSON.stringify({
              _webrtcSignal: {
                type: "ice-candidate",
                candidate: event.candidate,
                fromSocketId: socket.id,
                deviceType: myDeviceType,
              },
            })
          );
        } else {
          console.log("ICE candidate gathering complete");
        }
      };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          statusMessage.innerHTML =
            "Connection failed. Trying alternative method...";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      // Set timeout for WebRTC connection (15 seconds - increased for slower networks)
      webrtcTimeout = setTimeout(() => {
        if (!webrtcConnected) {
          console.log(
            "WebRTC timeout - connection state:",
            peerConnection?.connectionState
          );
          statusMessage.innerHTML =
            "Connection timeout. Trying alternative method...";
          fallbackToSocketIOSync();
        }
      }, 15000);

      // Create and send offer
      peerConnection
        .createOffer()
        .then((offer) => {
          return peerConnection.setLocalDescription(offer);
        })
        .then(() => {
          // Send WebRTC offer via sync event (wrapped in special format)
          socket.emit(
            "sync",
            JSON.stringify({
              _webrtcSignal: {
                type: "offer",
                offer: peerConnection.localDescription,
                fromSocketId: socket.id,
                deviceType: myDeviceType,
              },
            })
          );
          console.log(
            "WebRTC offer sent via sync (socket ID:",
            socket.id,
            "):",
            peerConnection.localDescription
          );
        })
        .catch((error) => {
          window.error("Error creating WebRTC offer:", error);
          statusMessage.innerHTML =
            "Connection error. Trying alternative method...";
          fallbackToSocketIOSync();
        });
    }

    function fallbackToSocketIOSync() {
      webrtcConnected = false;
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }
      statusMessage.innerHTML =
        "Using direct sync method.<br>Click 'Sync' to send data.";
      syncButton.style.display = "block";
      syncButton.disabled = false;
    }

    async function handleWebRTCOffer(offer) {
      if (webrtcConnected || !offer) return;

      console.log("Received WebRTC offer");
      statusMessage.innerHTML = "Connecting...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      // Handle incoming data channel
      peerConnection.ondatachannel = (event) => {
        console.log("Data channel received");
        setupDataChannel(event.channel);
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          iceCandidatesSent++;
          console.log(
            `Sending ICE candidate ${iceCandidatesSent}:`,
            event.candidate
          );
          // Send via sync event (wrapped in special format) to match other WebRTC signals
          socket.emit(
            "sync",
            JSON.stringify({
              _webrtcSignal: {
                type: "ice-candidate",
                candidate: event.candidate,
                fromSocketId: socket.id,
                deviceType: myDeviceType,
              },
            })
          );
        } else {
          console.log("ICE candidate gathering complete");
        }
      };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          statusMessage.innerHTML =
            "Connection failed. Trying alternative method...";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(offer)
        );
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        // Send WebRTC answer via sync event (wrapped in special format)
        socket.emit(
          "sync",
          JSON.stringify({
            _webrtcSignal: {
              type: "answer",
              answer: peerConnection.localDescription,
              fromSocketId: socket.id,
              deviceType: myDeviceType,
            },
          })
        );
        console.log(
          "WebRTC answer sent via sync (socket ID:",
          socket.id,
          "):",
          peerConnection.localDescription
        );
      } catch (error) {
        window.error("Error handling WebRTC offer:", error);
        statusMessage.innerHTML =
          "Connection error. Trying alternative method...";
        fallbackToSocketIOSync();
      }
    }

    async function handleWebRTCAnswer(answer) {
      if (webrtcConnected || !answer || !peerConnection) return;

      console.log("Received WebRTC answer");
      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(answer)
        );
        console.log("WebRTC connection established");
      } catch (error) {
        window.error("Error handling WebRTC answer:", error);
        statusMessage.innerHTML =
          "Connection error. Trying alternative method...";
        fallbackToSocketIOSync();
      }
    }

    function setupDataChannel(channel) {
      channel.onopen = () => {
        console.log("WebRTC data channel opened - starting sync");
        webrtcConnected = true;
        statusMessage.innerHTML = "Syncing data...";

        // Disconnect from Socket.io (no longer needed)
        if (socket) {
          socket.disconnect();
          console.log("Disconnected from signaling server");
        }

        // Auto-sync: both devices send their data
        performBidirectionalSync(channel);
      };

      channel.onmessage = async (event) => {
        try {
          const compressedData = event.data;
          const jsonData = decompressData(compressedData);
          console.log("Received data via WebRTC");
          await importData(jsonData);
          statusMessage.innerHTML = "Sync completed!";
        } catch (error) {
          window.error("Error processing received data:", error);
          statusMessage.innerHTML = "Sync error occurred";
        }
      };

      channel.onerror = (error) => {
        window.error("Data channel error:", error);
        statusMessage.innerHTML = "Sync error occurred";
        webrtcConnected = false;
      };

      channel.onclose = () => {
        console.log("Data channel closed");
        webrtcConnected = false;
        statusMessage.innerHTML = "Connection closed";
        // Clear connected devices when WebRTC closes
        connectedDevices = {};
        updateDeviceListDisplay();
      };
    }

    async function performBidirectionalSync(channel) {
      try {
        const jsonData = await exportData();
        const compressedData = compressData(jsonData);
        channel.send(compressedData);
        console.log("Sent data via WebRTC");
      } catch (error) {
        window.error("Error during sync:", error);
        statusMessage.innerHTML = "Sync error occurred";
      }
    }

    // Fallback: export to others via Socket.io (if WebRTC not available)
    syncButton.addEventListener("click", () => {
      if (webrtcConnected && dataChannel) {
        performBidirectionalSync(dataChannel);
      } else {
        statusMessage.innerHTML = "Sending data...";
        exportData().then((jsonData) => {
          const compressedData = compressData(jsonData);
          const encodedData = encodeURIComponent(compressedData);
          socket.emit("sync", encodedData);
        });
      }
    });

    //manually export
    document.getElementById("showData").addEventListener("click", () => {
      const dataDiv = document.querySelector(".data");
      const msgsTextarea = document.getElementById("msgs");
      dataDiv.classList.toggle("open");
      msgsTextarea.classList.toggle("hide", dataDiv.classList.contains("open"));

      exportData().then((jsonData) => {
        console.log(compressData(jsonData));
        document.getElementById("json").value = jsonData;
        document.getElementById("saveData").disabled = false;
      });
    });
    //validate json before saving
    document.getElementById("json").addEventListener("change", ({ target }) => {
      const isValidJSON = (value) => {
        try {
          JSON.parse(value);
          return true;
        } catch {
          return false;
        }
      };
      document.getElementById("saveData").disabled = !isValidJSON(target.value);
    });
    //manually import
    document.getElementById("saveData").addEventListener("click", () => {
      jsonData = document.getElementById("json").value;
      console.log("Manual import triggered");
      statusMessage.innerHTML = "Importing data...";
      importData(jsonData).then(() => {
        statusMessage.innerHTML = "Import completed!";
      });
    });

    // Cleanup function to disconnect socket and close WebRTC connections
    function cleanup() {
      console.log("Cleaning up socket and WebRTC connections...");

      // Cancel any pending offer creation
      if (offerCreationTimeout) {
        clearTimeout(offerCreationTimeout);
        offerCreationTimeout = null;
      }

      // Close WebRTC data channel
      if (dataChannel) {
        try {
          dataChannel.close();
        } catch (e) {
          console.error("Error closing data channel:", e);
        }
        dataChannel = null;
      }

      // Close WebRTC peer connection
      if (peerConnection) {
        try {
          peerConnection.close();
        } catch (e) {
          console.error("Error closing peer connection:", e);
        }
        peerConnection = null;
      }

      // Disconnect socket
      if (socket && socket.connected) {
        try {
          socket.disconnect();
          console.log("Socket disconnected");
        } catch (e) {
          console.error("Error disconnecting socket:", e);
        }
        socket = null;
      }

      // Clear connected devices
      connectedDevices = {};
      updateDeviceListDisplay();

      webrtcConnected = false;
      isInitiator = false;
      myDeviceType = null;
    }

    // Register cleanup with global route cleanup system
    const unregisterCleanup =
      window.routeCleanup?.register(cleanup) || (() => {});

    // Also cleanup on page unload (browser close/refresh)
    window.addEventListener("beforeunload", cleanup);

    // Load connect_id from IndexedDB and auto-connect
    getAppSetting("connect_id")
      .then((connect_id) => {
        if (connect_id) {
          console.log("connect_id set:", connect_id);
          codeInput.value = connect_id;
          const isValidCode = /^\d{3}-\d{3}$/.test(codeInput.value);
          if (isValidCode) {
            container.classList.toggle("validCode", isValidCode);
            // Only auto-connect if we're not already connected
            if (!socket || !socket.connected) {
              connectButton.click();
            }
          }
        }
      })
      .catch((error) => {
        console.error("Error loading connect_id:", error);
      });
  })();
</script>
