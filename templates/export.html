<link rel="stylesheet" href="./css/export.css" />
<main>
  <div class="status">
    <p>Sync data with other device.</p>
    <p id="status-message">Enter code and toggle the switch to connect.</p>
  </div>
  <div class="code-container">
    <input
      aria-label="connection code"
      type="tel"
      maxlength="7"
      id="code-input"
      pattern="[0-9]{3}-[0-9]{3}"
      placeholder="123-456"
    />
    <button id="generateButton"></button>
    <button title="connect devices" id="connectButton"></button>
  </div>
  <div class="controls">
    <button title="sync data" id="syncButton" disabled style="display: none">
      Sync
    </button>
  </div>
  <div id="userCount"></div>
  <textarea id="msgs"></textarea>
  <div class="data">
    <h2 id="showData">Show Data</h2>
    <div class="data-container">
      <textarea id="json"></textarea>
      <button title="save date" id="saveData" disabled>Save Data</button>
    </div>
  </div>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="./js/export.js"></script>
<script>
  (function () {
    const container = document.querySelector(".code-container");
    const codeInput = document.getElementById("code-input");
    const generateButton = document.getElementById("generateButton");
    const syncButton = document.getElementById("syncButton");
    const connectButton = document.getElementById("connectButton");
    const statusMessage = document.getElementById("status-message");
    //connectButton.style.visibility = 'hidden';
    let socket = null;
    let peerConnection = null;
    let dataChannel = null;
    let isInitiator = false;
    let webrtcConnected = false;
    let offerCreationTimeout = null;
    generateButton.addEventListener("click", () => {
      const randomCode = `${Math.floor(100 + Math.random() * 900)}-${Math.floor(
        100 + Math.random() * 900
      )}`;
      codeInput.value = randomCode;
      container.classList.add("validCode");
      //connectButton.style.visibility = 'visible';
    });
    codeInput.addEventListener("input", function (event) {
      let input = event.target;
      let value = input.value.replace(/\D/g, ""); // Remove any non-digit characters
      // Format as XXX-XXX
      if (value.length > 3) {
        value = value.slice(0, 3) + "-" + value.slice(3, 6);
      }
      input.value = value;
      const isValidCode = /^\d{3}-\d{3}$/.test(input.value);
      container.classList.toggle("validCode", isValidCode);
      //connectButton.style.visibility = isValidCode ? 'visible' : 'hidden';
    });
    connectButton.addEventListener("click", () => {
      const code = codeInput.value;
      syncButton.disabled = true;
      // Validate code format
      if (/^\d{3}-\d{3}$/.test(code)) {
        codeInput.style.display = "hidden";
        if (socket && socket.connected) {
          console.log("Disconnecting existing socket connection...");
          socket.disconnect(); // Disconnect the existing socket connection
          generateButton.style.display = "block";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          syncButton.disabled = true;
          return;
        }
        socket = io(`https://bw-socket-test.herokuapp.com/${code}`, {
          transports: ["websocket", "polling"],
          timeout: 10000,
          reconnection: false,
        });

        socket.on("connect", () => {
          console.log(`Connected with namespace: /${code}`);
          generateButton.style.display = "none";
          container.classList.add("connected");
          codeInput.readOnly = true;
          console.log("set connection id");
          setAppSetting("connect_id", code);

          // Determine if this device is the initiator (first to connect)
          // We'll use a simple approach: first device to connect becomes initiator
          socket.emit("checkInitiator");
        });

        socket.on("connect_error", (error) => {
          console.error("Socket.io connection error:", error);
          msg(
            "Connection error: " +
              (error.message || "Unable to connect to server")
          );
          statusMessage.innerHTML =
            "Connection failed. This may be due to CORS restrictions when running locally.<br>Try using the hosted version or configure the server to allow localhost.";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          generateButton.style.display = "block";
          if (socket) {
            socket.disconnect();
            socket = null;
          }
        });
        socket.on("userCount", (count) => {
          let userMsg = "";
          if (count > 1) {
            statusMessage.innerHTML = `Connected with ${
              count - 1
            } other device${
              count - 1 === 1 ? "" : "s"
            }.<br>Establishing peer connection...`;
            // Start WebRTC connection process when both devices are connected
            if (count === 2 && !webrtcConnected && !peerConnection && !offerCreationTimeout) {
              // Use socket ID as tiebreaker for deterministic initiator selection
              // Device with "smaller" socket ID becomes initiator
              const socketId = socket.id;
              const delay = Math.random() * 800 + 200; // 200-1000ms random delay
              
              // Add a small deterministic component based on socket ID
              const idHash = socketId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
              const deterministicDelay = (idHash % 500); // 0-500ms based on socket ID
              const totalDelay = delay + deterministicDelay;
              
              console.log(`Scheduling offer creation in ${totalDelay.toFixed(0)}ms (socket ID: ${socketId.substring(0, 8)}...)`);
              offerCreationTimeout = setTimeout(() => {
                // Only create offer if we still haven't received one
                if (!peerConnection && !webrtcConnected && !isInitiator) {
                  isInitiator = true;
                  console.log("This device is the initiator (creating offer)");
                  createWebRTCOffer();
                } else {
                  console.log("Skipping offer creation - already have connection or received offer");
                }
                offerCreationTimeout = null;
              }, totalDelay);
            }
          } else {
            statusMessage.innerHTML = "Waiting for another device to connectâ€¦";
          }
          const userCountEl = document.getElementById("userCount");
          if (userCountEl) {
            userCountEl.textContent = userMsg;
          }
        });

        // Handle both WebRTC signaling and regular sync via the existing 'sync' event
        // WebRTC signals are wrapped in { _webrtcSignal: {...} } format
        // Regular sync data is compressed/encoded as before
        // The server already broadcasts 'sync' events, so this works without server changes
        socket.on("sync", async (data) => {
          if (webrtcConnected) {
            // If already connected via WebRTC, ignore sync events (they're for fallback)
            return;
          }

          try {
            // Check if this is a WebRTC signal (wrapped in special format) or regular sync data
            let signalData = null;
            try {
              // Try to parse as WebRTC signal wrapper
              const parsed = typeof data === 'string' ? JSON.parse(data) : data;
              if (parsed && parsed._webrtcSignal) {
                signalData = parsed._webrtcSignal;
                console.log("Received WebRTC signal via sync:", signalData?.type, "from:", signalData?.fromSocketId || "unknown");
              }
            } catch (e) {
              // Not a WebRTC signal, treat as regular sync data (fallback)
              msg("sync request (fallback)");
              const jsonData = decompressData(decodeURIComponent(data));
          msg("Decompressed JSON Data:");
          console.log(jsonData);
          importData(jsonData).then(() => {
            msg("Import completed!");
          });
              return;
            }

            // Handle WebRTC signal
            if (!signalData) return;

            if (signalData.type === "offer") {
              // If we receive an offer, we're definitely the responder (regardless of current state)
              msg("Received WebRTC offer");
              // Cancel any pending offer creation
              if (offerCreationTimeout) {
                console.log("Cancelling pending offer creation - received offer from other device");
                clearTimeout(offerCreationTimeout);
                offerCreationTimeout = null;
              }
              if (peerConnection) {
                console.log("Already have peer connection, closing it to accept new offer");
                peerConnection.close();
                peerConnection = null;
              }
              // Mark as responder
              isInitiator = false;
              await handleWebRTCOffer(signalData.offer);
            } else if (signalData.type === "answer") {
              // Only handle answer if we're the initiator (we sent an offer)
              // If we received an offer first, we're the responder and should ignore answers
              if (isInitiator && peerConnection && peerConnection.localDescription && peerConnection.localDescription.type === "offer") {
                msg("Received WebRTC answer");
                await handleWebRTCAnswer(signalData.answer);
              } else {
                console.log("Ignoring answer - we're the responder, not the initiator");
              }
            } else if (signalData.type === "ice-candidate") {
              iceCandidatesReceived++;
              msg(`Received ICE candidate ${iceCandidatesReceived}`);
              console.log(`Received ICE candidate ${iceCandidatesReceived}:`, signalData.candidate);
              if (peerConnection) {
                try {
                  if (peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(
                      new RTCIceCandidate(signalData.candidate)
                    );
                  } else {
                    // Store candidate for later if remote description isn't set yet
                    console.log("Storing ICE candidate until remote description is set");
                    // The candidate will be added when remote description is set
                  }
                } catch (error) {
                  console.error("Error adding ICE candidate:", error);
                  window.error("Error adding ICE candidate:", error);
                }
              } else {
                console.log("Peer connection not created yet");
              }
            } else {
              console.log("Ignored signal:", signalData?.type, "isInitiator:", isInitiator);
            }
          } catch (error) {
            console.error("Error handling sync/signal:", error);
            window.error("Error handling sync/signal:", error);
          }
        });
      }
    });
      // WebRTC functions
      let webrtcTimeout = null;
      let iceCandidatesReceived = 0;
      let iceCandidatesSent = 0;

    function createWebRTCOffer() {
      msg("Creating WebRTC offer...");
      statusMessage.innerHTML = "Establishing peer connection...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

        // Create data channel
        dataChannel = peerConnection.createDataChannel("sync", { ordered: true });
        setupDataChannel(dataChannel);

        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            iceCandidatesSent++;
            console.log(`Sending ICE candidate ${iceCandidatesSent}:`, event.candidate);
            // Send WebRTC signal via sync event (wrapped in special format)
            socket.emit("sync", JSON.stringify({
              _webrtcSignal: {
                type: "ice-candidate",
                candidate: event.candidate,
                fromSocketId: socket.id,
              }
            }));
          } else {
            console.log("ICE candidate gathering complete");
          }
        };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          msg("WebRTC connection failed, falling back to Socket.io");
          statusMessage.innerHTML = "Connection failed. Using fallback method.";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      // Set timeout for WebRTC connection (15 seconds - increased for slower networks)
      webrtcTimeout = setTimeout(() => {
        if (!webrtcConnected) {
          msg("WebRTC connection timeout, falling back to Socket.io");
          console.log("WebRTC timeout - connection state:", peerConnection?.connectionState);
          statusMessage.innerHTML =
            "Connection timeout. Using fallback method.";
          fallbackToSocketIOSync();
        }
      }, 15000);

      // Create and send offer
      peerConnection
        .createOffer()
        .then((offer) => {
          return peerConnection.setLocalDescription(offer);
        })
        .then(() => {
        // Send WebRTC offer via sync event (wrapped in special format)
        socket.emit("sync", JSON.stringify({
          _webrtcSignal: {
            type: "offer",
            offer: peerConnection.localDescription,
            fromSocketId: socket.id,
          }
        }));
        msg("WebRTC offer sent");
        console.log("WebRTC offer sent via sync (socket ID:", socket.id, "):", peerConnection.localDescription);
        })
        .catch((error) => {
          window.error("Error creating WebRTC offer:", error);
          msg("Error creating offer, using fallback");
          fallbackToSocketIOSync();
        });
    }

    function fallbackToSocketIOSync() {
      webrtcConnected = false;
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }
      statusMessage.innerHTML =
        "Using direct sync method.<br>Click 'Sync' to send data.";
      syncButton.style.display = "block";
      syncButton.disabled = false;
    }

    async function handleWebRTCOffer(offer) {
      if (webrtcConnected || !offer) return;

      msg("Received WebRTC offer");
      statusMessage.innerHTML = "Establishing peer connection...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      // Handle incoming data channel
      peerConnection.ondatachannel = (event) => {
        msg("Data channel received");
        setupDataChannel(event.channel);
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          iceCandidatesSent++;
          console.log(`Sending ICE candidate ${iceCandidatesSent}:`, event.candidate);
          socket.emit("webrtc-signal", {
            type: "ice-candidate",
            candidate: event.candidate,
          });
        } else {
          console.log("ICE candidate gathering complete");
        }
      };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          msg("WebRTC connection failed, falling back to Socket.io");
          statusMessage.innerHTML = "Connection failed. Using fallback method.";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(offer)
        );
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        // Send WebRTC answer via sync event (wrapped in special format)
        socket.emit("sync", JSON.stringify({
          _webrtcSignal: {
            type: "answer",
            answer: peerConnection.localDescription,
            fromSocketId: socket.id,
          }
        }));
        msg("WebRTC answer sent");
        console.log("WebRTC answer sent via sync (socket ID:", socket.id, "):", peerConnection.localDescription);
      } catch (error) {
        window.error("Error handling WebRTC offer:", error);
        msg("Error handling offer, using fallback");
        fallbackToSocketIOSync();
      }
    }

    async function handleWebRTCAnswer(answer) {
      if (webrtcConnected || !answer || !peerConnection) return;

      msg("Received WebRTC answer");
      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(answer)
        );
        msg("WebRTC connection established");
      } catch (error) {
        window.error("Error handling WebRTC answer:", error);
        msg("Error handling answer, using fallback");
        fallbackToSocketIOSync();
      }
    }

    function setupDataChannel(channel) {
      channel.onopen = () => {
        msg("WebRTC data channel opened - starting sync");
        webrtcConnected = true;
        statusMessage.innerHTML = "Syncing data...";

        // Disconnect from Socket.io (no longer needed)
        if (socket) {
          socket.disconnect();
          msg("Disconnected from signaling server");
        }

        // Auto-sync: both devices send their data
        performBidirectionalSync(channel);
      };

      channel.onmessage = async (event) => {
        try {
          const compressedData = event.data;
          const jsonData = decompressData(compressedData);
          msg("Received data via WebRTC");
          await importData(jsonData);
          msg("Import completed!");
          statusMessage.innerHTML = "Sync completed!";
        } catch (error) {
          window.error("Error processing received data:", error);
          msg(`Error: ${error.message}`);
          statusMessage.innerHTML = "Sync error occurred";
        }
      };

      channel.onerror = (error) => {
        window.error("Data channel error:", error);
        msg("Data channel error");
        webrtcConnected = false;
      };

      channel.onclose = () => {
        msg("Data channel closed");
        webrtcConnected = false;
        statusMessage.innerHTML = "Connection closed";
      };
    }

    async function performBidirectionalSync(channel) {
      try {
        const jsonData = await exportData();
        const compressedData = compressData(jsonData);
        channel.send(compressedData);
        msg("Sent data via WebRTC");
      } catch (error) {
        window.error("Error during sync:", error);
        msg(`Sync error: ${error.message}`);
      }
    }

    // Fallback: export to others via Socket.io (if WebRTC not available)
    syncButton.addEventListener("click", () => {
      if (webrtcConnected && dataChannel) {
        performBidirectionalSync(dataChannel);
      } else {
        msg("sending export (fallback)");
      exportData().then((jsonData) => {
        const compressedData = compressData(jsonData);
        const encodedData = encodeURIComponent(compressedData);
        socket.emit("sync", encodedData);
      });
      }
    });

    //manually export
    document.getElementById("showData").addEventListener("click", () => {
      const dataDiv = document.querySelector(".data");
      const msgsTextarea = document.getElementById("msgs");
      dataDiv.classList.toggle("open");
      msgsTextarea.classList.toggle("hide", dataDiv.classList.contains("open"));

      exportData().then((jsonData) => {
        console.log(compressData(jsonData));
        document.getElementById("json").value = jsonData;
        document.getElementById("saveData").disabled = false;
      });
    });
    //validate json before saving
    document.getElementById("json").addEventListener("change", ({ target }) => {
      const isValidJSON = (value) => {
        try {
          JSON.parse(value);
          return true;
        } catch {
          return false;
        }
      };
      document.getElementById("saveData").disabled = !isValidJSON(target.value);
    });
    //manually import
    document.getElementById("saveData").addEventListener("click", () => {
      jsonData = document.getElementById("json").value;
      msg("saveData");
      msg(jsonData);
      importData(jsonData).then(() => {
        msg("Import completed!");
      });
    });

    // Cleanup function to disconnect socket and close WebRTC connections
    function cleanup() {
      console.log("Cleaning up socket and WebRTC connections...");

      // Cancel any pending offer creation
      if (offerCreationTimeout) {
        clearTimeout(offerCreationTimeout);
        offerCreationTimeout = null;
      }

      // Close WebRTC data channel
      if (dataChannel) {
        try {
          dataChannel.close();
        } catch (e) {
          console.error("Error closing data channel:", e);
        }
        dataChannel = null;
      }

      // Close WebRTC peer connection
      if (peerConnection) {
        try {
          peerConnection.close();
        } catch (e) {
          console.error("Error closing peer connection:", e);
        }
        peerConnection = null;
      }

      // Disconnect socket
      if (socket && socket.connected) {
        try {
          socket.disconnect();
          console.log("Socket disconnected");
        } catch (e) {
          console.error("Error disconnecting socket:", e);
        }
        socket = null;
      }

      webrtcConnected = false;
      isInitiator = false;
    }

    // Register cleanup with global route cleanup system
    const unregisterCleanup =
      window.routeCleanup?.register(cleanup) || (() => {});

    // Also cleanup on page unload (browser close/refresh)
    window.addEventListener("beforeunload", cleanup);

    // Load connect_id from IndexedDB and auto-connect
    getAppSetting("connect_id")
      .then((connect_id) => {
    if (connect_id) {
      console.log("connect_id set:", connect_id);
      codeInput.value = connect_id;
      const isValidCode = /^\d{3}-\d{3}$/.test(codeInput.value);
      if (isValidCode) {
        container.classList.toggle("validCode", isValidCode);
            // Only auto-connect if we're not already connected
            if (!socket || !socket.connected) {
        connectButton.click();
      }
    }
        }
      })
      .catch((error) => {
        console.error("Error loading connect_id:", error);
      });
  })();
</script>
