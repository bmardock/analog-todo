<link rel="stylesheet" href="./css/export.css" />
<main>
  <div class="status">
    <p>Sync data with other device.</p>
    <p id="status-message">Enter code and toggle the switch to connect.</p>
  </div>
  <div class="code-container">
    <input
      aria-label="connection code"
      type="tel"
      maxlength="7"
      id="code-input"
      pattern="[0-9]{3}-[0-9]{3}"
      placeholder="123-456"
    />
    <button id="generateButton"></button>
    <button title="connect devices" id="connectButton"></button>
  </div>
  <div class="controls">
    <button title="sync data" id="syncButton" disabled style="display: none">
      Sync
    </button>
  </div>
  <div id="userCount"></div>
  <textarea id="msgs"></textarea>
  <div class="data">
    <h2 id="showData">Show Data</h2>
    <div class="data-container">
      <textarea id="json"></textarea>
      <button title="save date" id="saveData" disabled>Save Data</button>
    </div>
  </div>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="./js/export.js"></script>
<script>
  (function () {
    const container = document.querySelector(".code-container");
    const codeInput = document.getElementById("code-input");
    const generateButton = document.getElementById("generateButton");
    const syncButton = document.getElementById("syncButton");
    const connectButton = document.getElementById("connectButton");
    const statusMessage = document.getElementById("status-message");
    //connectButton.style.visibility = 'hidden';
    let socket = null;
    let peerConnection = null;
    let dataChannel = null;
    let isInitiator = false;
    let webrtcConnected = false;
    generateButton.addEventListener("click", () => {
      const randomCode = `${Math.floor(100 + Math.random() * 900)}-${Math.floor(
        100 + Math.random() * 900
      )}`;
      codeInput.value = randomCode;
      container.classList.add("validCode");
      //connectButton.style.visibility = 'visible';
    });
    codeInput.addEventListener("input", function (event) {
      let input = event.target;
      let value = input.value.replace(/\D/g, ""); // Remove any non-digit characters
      // Format as XXX-XXX
      if (value.length > 3) {
        value = value.slice(0, 3) + "-" + value.slice(3, 6);
      }
      input.value = value;
      const isValidCode = /^\d{3}-\d{3}$/.test(input.value);
      container.classList.toggle("validCode", isValidCode);
      //connectButton.style.visibility = isValidCode ? 'visible' : 'hidden';
    });
    connectButton.addEventListener("click", () => {
      const code = codeInput.value;
      syncButton.disabled = true;
      // Validate code format
      if (/^\d{3}-\d{3}$/.test(code)) {
        codeInput.style.display = "hidden";
        if (socket && socket.connected) {
          console.log("Disconnecting existing socket connection...");
          socket.disconnect(); // Disconnect the existing socket connection
          generateButton.style.display = "block";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          syncButton.disabled = true;
          return;
        }
        socket = io(`https://bw-socket-test.herokuapp.com/${code}`, {
          transports: ["websocket", "polling"],
          timeout: 10000,
          reconnection: false,
        });

        socket.on("connect", () => {
          console.log(`Connected with namespace: /${code}`);
          generateButton.style.display = "none";
          container.classList.add("connected");
          codeInput.readOnly = true;
          console.log("set connection id");
          setAppSetting("connect_id", code);

          // Determine if this device is the initiator (first to connect)
          // We'll use a simple approach: first device to connect becomes initiator
          socket.emit("checkInitiator");
        });

        socket.on("connect_error", (error) => {
          console.error("Socket.io connection error:", error);
          msg(
            "Connection error: " +
              (error.message || "Unable to connect to server")
          );
          statusMessage.innerHTML =
            "Connection failed. This may be due to CORS restrictions when running locally.<br>Try using the hosted version or configure the server to allow localhost.";
          container.classList.remove("connected");
          codeInput.readOnly = false;
          generateButton.style.display = "block";
          if (socket) {
            socket.disconnect();
            socket = null;
          }
        });
        socket.on("userCount", (count) => {
          let userMsg = "";
          if (count > 1) {
            statusMessage.innerHTML = `Connected with ${
              count - 1
            } other device${
              count - 1 === 1 ? "" : "s"
            }.<br>Establishing peer connection...`;
            // Start WebRTC connection process when both devices are connected
            if (count === 2 && !webrtcConnected && !peerConnection) {
              // Simple approach: random delay to determine initiator
              // First device to act becomes initiator, other becomes responder
              const delay = Math.random() * 500 + 100; // 100-600ms random delay
              setTimeout(() => {
                // Only create offer if we haven't received one yet
                if (!peerConnection && !webrtcConnected) {
                  isInitiator = true;
                  createWebRTCOffer();
                }
              }, delay);
            }
          } else {
            statusMessage.innerHTML = "Waiting for another device to connectâ€¦";
          }
          const userCountEl = document.getElementById("userCount");
          if (userCountEl) {
            userCountEl.textContent = userMsg;
          }
        });

        // WebRTC signaling events - using a wrapper object to work with existing server
        // Note: Server must support broadcasting custom events in the namespace
        socket.on("webrtc-signal", async (signalData) => {
          if (webrtcConnected) return; // Ignore if already connected

          try {
            if (signalData && signalData.type === "offer" && !isInitiator) {
              await handleWebRTCOffer(signalData.offer);
            } else if (
              signalData &&
              signalData.type === "answer" &&
              isInitiator
            ) {
              await handleWebRTCAnswer(signalData.answer);
            } else if (signalData && signalData.type === "ice-candidate") {
              if (peerConnection && peerConnection.remoteDescription) {
                try {
                  await peerConnection.addIceCandidate(
                    new RTCIceCandidate(signalData.candidate)
                  );
                } catch (error) {
                  window.error("Error adding ICE candidate:", error);
                }
              }
            }
          } catch (error) {
            window.error("Error handling WebRTC signal:", error);
          }
        });

        // Fallback: old sync method via Socket.io (if WebRTC fails)
        socket.on("sync", (compressedData) => {
          if (!webrtcConnected) {
            msg("sync request (fallback)");
            const jsonData = decompressData(decodeURIComponent(compressedData));
            msg("Decompressed JSON Data:");
            console.log(jsonData);
            importData(jsonData).then(() => {
              msg("Import completed!");
            });
          }
        });
      }
    });
    // WebRTC functions
    let webrtcTimeout = null;

    function createWebRTCOffer() {
      msg("Creating WebRTC offer...");
      statusMessage.innerHTML = "Establishing peer connection...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      // Create data channel
      dataChannel = peerConnection.createDataChannel("sync", { ordered: true });
      setupDataChannel(dataChannel);

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("webrtc-signal", {
            type: "ice-candidate",
            candidate: event.candidate,
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          msg("WebRTC connection failed, falling back to Socket.io");
          statusMessage.innerHTML = "Connection failed. Using fallback method.";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      // Set timeout for WebRTC connection (10 seconds)
      webrtcTimeout = setTimeout(() => {
        if (!webrtcConnected) {
          msg("WebRTC connection timeout, falling back to Socket.io");
          statusMessage.innerHTML =
            "Connection timeout. Using fallback method.";
          fallbackToSocketIOSync();
        }
      }, 10000);

      // Create and send offer
      peerConnection
        .createOffer()
        .then((offer) => {
          return peerConnection.setLocalDescription(offer);
        })
        .then(() => {
          socket.emit("webrtc-signal", {
            type: "offer",
            offer: peerConnection.localDescription,
          });
          msg("WebRTC offer sent");
        })
        .catch((error) => {
          window.error("Error creating WebRTC offer:", error);
          msg("Error creating offer, using fallback");
          fallbackToSocketIOSync();
        });
    }

    function fallbackToSocketIOSync() {
      webrtcConnected = false;
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }
      statusMessage.innerHTML =
        "Using direct sync method.<br>Click 'Sync' to send data.";
      syncButton.style.display = "block";
      syncButton.disabled = false;
    }

    async function handleWebRTCOffer(offer) {
      if (webrtcConnected || !offer) return;

      msg("Received WebRTC offer");
      statusMessage.innerHTML = "Establishing peer connection...";

      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      });

      // Handle incoming data channel
      peerConnection.ondatachannel = (event) => {
        msg("Data channel received");
        setupDataChannel(event.channel);
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("webrtc-signal", {
            type: "ice-candidate",
            candidate: event.candidate,
          });
        }
      };

      peerConnection.onconnectionstatechange = () => {
        window.log("WebRTC connection state:", peerConnection.connectionState);
        if (peerConnection.connectionState === "connected") {
          if (webrtcTimeout) {
            clearTimeout(webrtcTimeout);
            webrtcTimeout = null;
          }
        } else if (
          peerConnection.connectionState === "failed" ||
          peerConnection.connectionState === "disconnected"
        ) {
          msg("WebRTC connection failed, falling back to Socket.io");
          statusMessage.innerHTML = "Connection failed. Using fallback method.";
          webrtcConnected = false;
          fallbackToSocketIOSync();
        }
      };

      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(offer)
        );
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit("webrtc-signal", {
          type: "answer",
          answer: peerConnection.localDescription,
        });
        msg("WebRTC answer sent");
      } catch (error) {
        window.error("Error handling WebRTC offer:", error);
        msg("Error handling offer, using fallback");
        fallbackToSocketIOSync();
      }
    }

    async function handleWebRTCAnswer(answer) {
      if (webrtcConnected || !answer || !peerConnection) return;

      msg("Received WebRTC answer");
      try {
        await peerConnection.setRemoteDescription(
          new RTCSessionDescription(answer)
        );
        msg("WebRTC connection established");
      } catch (error) {
        window.error("Error handling WebRTC answer:", error);
        msg("Error handling answer, using fallback");
        fallbackToSocketIOSync();
      }
    }

    function setupDataChannel(channel) {
      channel.onopen = () => {
        msg("WebRTC data channel opened - starting sync");
        webrtcConnected = true;
        statusMessage.innerHTML = "Syncing data...";

        // Disconnect from Socket.io (no longer needed)
        if (socket) {
          socket.disconnect();
          msg("Disconnected from signaling server");
        }

        // Auto-sync: both devices send their data
        performBidirectionalSync(channel);
      };

      channel.onmessage = async (event) => {
        try {
          const compressedData = event.data;
          const jsonData = decompressData(compressedData);
          msg("Received data via WebRTC");
          await importData(jsonData);
          msg("Import completed!");
          statusMessage.innerHTML = "Sync completed!";
        } catch (error) {
          window.error("Error processing received data:", error);
          msg(`Error: ${error.message}`);
          statusMessage.innerHTML = "Sync error occurred";
        }
      };

      channel.onerror = (error) => {
        window.error("Data channel error:", error);
        msg("Data channel error");
        webrtcConnected = false;
      };

      channel.onclose = () => {
        msg("Data channel closed");
        webrtcConnected = false;
        statusMessage.innerHTML = "Connection closed";
      };
    }

    async function performBidirectionalSync(channel) {
      try {
        const jsonData = await exportData();
        const compressedData = compressData(jsonData);
        channel.send(compressedData);
        msg("Sent data via WebRTC");
      } catch (error) {
        window.error("Error during sync:", error);
        msg(`Sync error: ${error.message}`);
      }
    }

    // Fallback: export to others via Socket.io (if WebRTC not available)
    syncButton.addEventListener("click", () => {
      if (webrtcConnected && dataChannel) {
        performBidirectionalSync(dataChannel);
      } else {
        msg("sending export (fallback)");
        exportData().then((jsonData) => {
          const compressedData = compressData(jsonData);
          const encodedData = encodeURIComponent(compressedData);
          socket.emit("sync", encodedData);
        });
      }
    });

    //manually export
    document.getElementById("showData").addEventListener("click", () => {
      const dataDiv = document.querySelector(".data");
      const msgsTextarea = document.getElementById("msgs");
      dataDiv.classList.toggle("open");
      msgsTextarea.classList.toggle("hide", dataDiv.classList.contains("open"));

      exportData().then((jsonData) => {
        console.log(compressData(jsonData));
        document.getElementById("json").value = jsonData;
        document.getElementById("saveData").disabled = false;
      });
    });
    //validate json before saving
    document.getElementById("json").addEventListener("change", ({ target }) => {
      const isValidJSON = (value) => {
        try {
          JSON.parse(value);
          return true;
        } catch {
          return false;
        }
      };
      document.getElementById("saveData").disabled = !isValidJSON(target.value);
    });
    //manually import
    document.getElementById("saveData").addEventListener("click", () => {
      jsonData = document.getElementById("json").value;
      msg("saveData");
      msg(jsonData);
      importData(jsonData).then(() => {
        msg("Import completed!");
      });
    });

    // Cleanup function to disconnect socket and close WebRTC connections
    function cleanup() {
      console.log("Cleaning up socket and WebRTC connections...");

      // Close WebRTC data channel
      if (dataChannel) {
        try {
          dataChannel.close();
        } catch (e) {
          console.error("Error closing data channel:", e);
        }
        dataChannel = null;
      }

      // Close WebRTC peer connection
      if (peerConnection) {
        try {
          peerConnection.close();
        } catch (e) {
          console.error("Error closing peer connection:", e);
        }
        peerConnection = null;
      }

      // Disconnect socket
      if (socket && socket.connected) {
        try {
          socket.disconnect();
          console.log("Socket disconnected");
        } catch (e) {
          console.error("Error disconnecting socket:", e);
        }
        socket = null;
      }

      webrtcConnected = false;
      isInitiator = false;
    }

    // Register cleanup with global route cleanup system
    const unregisterCleanup =
      window.routeCleanup?.register(cleanup) || (() => {});

    // Also cleanup on page unload (browser close/refresh)
    window.addEventListener("beforeunload", cleanup);

    // Load connect_id from IndexedDB and auto-connect
    getAppSetting("connect_id")
      .then((connect_id) => {
        if (connect_id) {
          console.log("connect_id set:", connect_id);
          codeInput.value = connect_id;
          const isValidCode = /^\d{3}-\d{3}$/.test(codeInput.value);
          if (isValidCode) {
            container.classList.toggle("validCode", isValidCode);
            // Only auto-connect if we're not already connected
            if (!socket || !socket.connected) {
              connectButton.click();
            }
          }
        }
      })
      .catch((error) => {
        console.error("Error loading connect_id:", error);
      });
  })();
</script>
